## 자료구조란
> 💡데이터를 저장하고 관리하는 방식

데이터를 저장하고 관리하는 방식을 자료구조라고 한다. 자료구조는 데이터를 체계적으로 저장하여 메모리를 효율적으로 사용할 수 있게 하고, 빠르고 안정적으로 데이터를 처리할 수 있도록 도와준다.

## 자료구조의 종류
- linear
  - List
    - Array List
      - Array
      - Dynamic Array
    - linked list
      - Node
  - queue
  - stack
  - hash table
- non-linear
  - tree
  - graph

## 자료구조를 배워야 하는 이유
자료구조와 알고리즘은 긴밀한 관계가 있다. 특정 알고리즘을 구현하기 위해서 꼭 사용해야 하는 자료구조가 있을 수 있고, 어떤 자료구조를 선택했는지에 따라서 사용할 수 있는 알고리즘이 달라진다.

## 알고리즘
>🍭 문제 해결 방법; 어떠한 문제를 해결하기 위해 정해진 일련의 절차나 방법
- 자주 쓰이는 문제 해결 방법(알고리즘)은 패턴화
  - BFS, DFS, Binary Search, Dijkstra  등
- 한 문제를 해결할 수 있는 알고리즘은 다양하다.
  - 각 문제에 적합한 알고리즘을 선택할 수 있어야 한다.
  - 알고리즘을 평가할 수 있어야 한다.

## 알고리즘 평가기준
- **시간 복잡도(Time Complexity)**
- 공간 복잡도(Space Complexity)
- 구현 복잡도

시간 복잡도와 공간 복잡도는 보통 trade-off 관계이다. 실행시간을 줄이기 위해서는 메모리를 더 사용해야 하고, 메모리 사용량을 줄이다보면 실행시간이 늘어나게 된다.

### 시간복잡도
> 알고리즘을 수행하는데 걸리는 시간을 설명하는 계산 복잡도(Computational Complexity)를 의미하며, 계산복잡도를 표기하는 대표적인 방법이 빅오다.   
> 빅오(O, big-O)란 입력값이 무한대로 향할 때 함수의 상한을 설명하는 수학적 표기 방법으로 시간복잡도를 표현할 때는 최고 차항만을 표기하며, 계수는 무시한다.
> 시간복잡도(big-O)에 데이터의 크기(n)를 넣어서 나온 값이 100,000,000(10^8)이 넘으면 시간 제한 초과할 가능성이 있다.

![big-O](/images/big-o.png)

- O(1) : 입력값이 아무리 커도 실행 시간은 일정하다. O(1)에 실행되는 알고리즘으로 **해시 테이블의 조회 및 삽입**이 이에 해당한다.
- O(log n) : 로그는 매우 큰 입력값에도 크게 영향을 받지 않는 편으로, **이진 검색**이 이에 해당한다.
- O(n) : 입력값만큼 실행 시간에 영향을 받으며, 알고리즘을 수행하는데 걸리는 시간은 입력값에 비례한다. 이러한 알고리즘을 선형 시간(linear-time) 알고리즘이라고 한다. 정렬되지 않은 리스트에 최댓값과 최솟값을 찾는 경우가 이에 해당하며 이 값을 찾기 위해서는 모든 입력값을 적어도 한 번 이상은 살펴봐야 한다.
- O(n log n) : 병합 정렬을 비롯한 대부분의 효율 좋은 정렬 알고리즘이 이에 해당한다. 적어도 모든 수에 대해 한 번 이상은 비교해야 하는 비교 기반 정렬 알고리즘은 아무리 좋은 알고리즘도 O(n log n) 보다 빠를 수 없다.
- O(n^2) : 버블 정렬 같은 비효율적인 정렬 알고리즘이 이에 해당한다.
- O(2^n) : 피보나치 수를 재귀로 계산하는 알고리즘이 이에 해당한다.
- O(n!) : 각 도시를 방문하고 돌아오는 가장 짧은 경로를 찾는 외판원 문제(Travelling Saleman Problem)를 브루트 포스로 풀이할 때가 이에 해당한다. 가장 느린 알고리즘으로, 입력값이 조금만 커져도 웬만한 다항 시간 내에는 계산이 어렵다.
